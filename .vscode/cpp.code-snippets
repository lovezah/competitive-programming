{
  "dijkstra": {
    "prefix": "!dijkstra",
    "body": [
      "template <typename T>",
      "vector<T> dijkstra(const vector<vector<pair<int, int>>> &E, int source = 0) {",
      "  const T INF = numeric_limits<T>::max() / 2;",
      "  int N = int(E.size());",
      "  vector<T> d(N, INF);",
      "  d[source] = 0;",
      "  using dij_t = pair<T, int>;",
      "  priority_queue<dij_t, vector<dij_t>, greater<dij_t>> PQ;",
      "  PQ.emplace(d[source], source);",
      "  while (!PQ.empty()) {",
      "    auto [exp, u] = PQ.top();",
      "    PQ.pop();",
      "    if (exp != d[u]) {",
      "      continue;",
      "    }",
      "    for (auto [v, w] : E[u]) {",
      "      if (d[v] > d[u] + w) {",
      "        d[v] = d[u] + w;",
      "        PQ.emplace(d[v], v);",
      "      }",
      "    }",
      "  }",
      "  for (int i = 0; i < N; i++) {",
      "    if (d[i] == INF) {",
      "      d[i] = -1;",
      "    }",
      "  }",
      "  return d;",
      "}"
    ],
    "description": "dijkstra"
  },
  "CartesianTree": {
    "prefix": "!CartesianTree",
    "body": [
      "// https://nyaannyaan.github.io/library/tree/cartesian-tree.hpp.html",
      "template <typename T>",
      "pair<vector<vector<int>>, int> CartesianTree(vector<T> &a) {",
      "  int N = (int)a.size();",
      "  vector<vector<int>> g(N);",
      "  vector<int> p(N, -1), st;",
      "  st.reserve(N);",
      "  for (int i = 0; i < N; i++) {",
      "    int prv = -1;",
      "    while (!st.empty() && a[i] < a[st.back()]) {",
      "      prv = st.back();",
      "      st.pop_back();",
      "    }",
      "    if (prv != -1) p[prv] = i;",
      "    if (!st.empty()) p[i] = st.back();",
      "    st.push_back(i);",
      "  }",
      "  int root = -1;",
      "  for (int i = 0; i < N; i++) {",
      "    if (p[i] != -1)",
      "      g[p[i]].push_back(i);",
      "    else",
      "      root = i;",
      "  }",
      "  return make_pair(g, root);",
      "}"
    ],
    "description": "CartesianTree"
  },
  "lazy_segtree": {
    "prefix": "!lazy_segtree",
    "body": [
      "namespace atcoder {",
      "namespace internal {",
      "#if __cplusplus >= 202002L",
      "using std::bit_ceil;",
      "#else",
      "// @return same with std::bit::bit_ceil",
      "unsigned int bit_ceil(unsigned int n) {",
      "  unsigned int x = 1;",
      "  while (x < (unsigned int)(n)) x *= 2;",
      "  return x;",
      "}",
      "#endif",
      "// @param n `1 <= n`",
      "// @return same with std::bit::countr_zero",
      "int countr_zero(unsigned int n) {",
      "#ifdef _MSC_VER",
      "  unsigned long index;",
      "  BitScanForward(&index, n);",
      "  return index;",
      "#else",
      "  return __builtin_ctz(n);",
      "#endif",
      "}",
      "// @param n `1 <= n`",
      "// @return same with std::bit::countr_zero",
      "constexpr int countr_zero_constexpr(unsigned int n) {",
      "  int x = 0;",
      "  while (!(n & (1 << x))) x++;",
      "  return x;",
      "}",
      "}  // namespace internal",
      "}  // namespace atcoder",
      "",
      "namespace atcoder {",
      "#if __cplusplus >= 201703L",
      "template <class S, auto op, auto e, class F, auto mapping, auto composition,",
      "          auto id>",
      "struct lazy_segtree {",
      "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,",
      "                \"op must work as S(S, S)\");",
      "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,",
      "                \"e must work as S()\");",
      "  static_assert(",
      "      std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,",
      "      \"mapping must work as S(F, S)\");",
      "  static_assert(",
      "      std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,",
      "      \"composition must work as F(F, F)\");",
      "  static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,",
      "                \"id must work as F()\");",
      "#else",
      "template <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),",
      "          F (*composition)(F, F), F (*id)()>",
      "struct lazy_segtree {",
      "#endif",
      " public:",
      "  lazy_segtree() : lazy_segtree(0) {}",
      "  explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
      "  explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {",
      "    size = (int)internal::bit_ceil((unsigned int)(_n));",
      "    log = internal::countr_zero((unsigned int)size);",
      "    d = std::vector<S>(2 * size, e());",
      "    lz = std::vector<F>(size, id());",
      "    for (int i = 0; i < _n; i++) d[size + i] = v[i];",
      "    for (int i = size - 1; i >= 1; i--) {",
      "      update(i);",
      "    }",
      "  }",
      "  void set(int p, S x) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    d[p] = x;",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "  S get(int p) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    return d[p];",
      "  }",
      "  S prod(int l, int r) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r) return e();",
      "    l += size;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l) push(l >> i);",
      "      if (((r >> i) << i) != r) push((r - 1) >> i);",
      "    }",
      "    S sml = e(), smr = e();",
      "    while (l < r) {",
      "      if (l & 1) sml = op(sml, d[l++]);",
      "      if (r & 1) smr = op(d[--r], smr);",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "    return op(sml, smr);",
      "  }",
      "  S all_prod() { return d[1]; }",
      "  void apply(int p, F f) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    for (int i = log; i >= 1; i--) push(p >> i);",
      "    d[p] = mapping(f, d[p]);",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "  void apply(int l, int r, F f) {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    if (l == r) return;",
      "    l += size;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) {",
      "      if (((l >> i) << i) != l) push(l >> i);",
      "      if (((r >> i) << i) != r) push((r - 1) >> i);",
      "    }",
      "    {",
      "      int l2 = l, r2 = r;",
      "      while (l < r) {",
      "        if (l & 1) all_apply(l++, f);",
      "        if (r & 1) all_apply(--r, f);",
      "        l >>= 1;",
      "        r >>= 1;",
      "      }",
      "      l = l2;",
      "      r = r2;",
      "    }",
      "    for (int i = 1; i <= log; i++) {",
      "      if (((l >> i) << i) != l) update(l >> i);",
      "      if (((r >> i) << i) != r) update((r - 1) >> i);",
      "    }",
      "  }",
      "  template <bool (*g)(S)>",
      "  int max_right(int l) {",
      "    return max_right(l, [](S x) { return g(x); });",
      "  }",
      "  template <class G>",
      "  int max_right(int l, G g) {",
      "    assert(0 <= l && l <= _n);",
      "    assert(g(e()));",
      "    if (l == _n) return _n;",
      "    l += size;",
      "    for (int i = log; i >= 1; i--) push(l >> i);",
      "    S sm = e();",
      "    do {",
      "      while (l % 2 == 0) l >>= 1;",
      "      if (!g(op(sm, d[l]))) {",
      "        while (l < size) {",
      "          push(l);",
      "          l = (2 * l);",
      "          if (g(op(sm, d[l]))) {",
      "            sm = op(sm, d[l]);",
      "            l++;",
      "          }",
      "        }",
      "        return l - size;",
      "      }",
      "      sm = op(sm, d[l]);",
      "      l++;",
      "    } while ((l & -l) != l);",
      "    return _n;",
      "  }",
      "  template <bool (*g)(S)>",
      "  int min_left(int r) {",
      "    return min_left(r, [](S x) { return g(x); });",
      "  }",
      "  template <class G>",
      "  int min_left(int r, G g) {",
      "    assert(0 <= r && r <= _n);",
      "    assert(g(e()));",
      "    if (r == 0) return 0;",
      "    r += size;",
      "    for (int i = log; i >= 1; i--) push((r - 1) >> i);",
      "    S sm = e();",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2)) r >>= 1;",
      "      if (!g(op(d[r], sm))) {",
      "        while (r < size) {",
      "          push(r);",
      "          r = (2 * r + 1);",
      "          if (g(op(d[r], sm))) {",
      "            sm = op(d[r], sm);",
      "            r--;",
      "          }",
      "        }",
      "        return r + 1 - size;",
      "      }",
      "      sm = op(d[r], sm);",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      "",
      " private:",
      "  int _n, size, log;",
      "  std::vector<S> d;",
      "  std::vector<F> lz;",
      "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "  void all_apply(int k, F f) {",
      "    d[k] = mapping(f, d[k]);",
      "    if (k < size) lz[k] = composition(f, lz[k]);",
      "  }",
      "  void push(int k) {",
      "    all_apply(2 * k, lz[k]);",
      "    all_apply(2 * k + 1, lz[k]);",
      "    lz[k] = id();",
      "  }",
      "};",
      "}  // namespace atcoder"
    ],
    "description": "lazy_segtree"
  },
  "StronglyConnectedComponents": {
    "prefix": "!StronglyConnectedComponents",
    "body": [
      "vector<vector<int>> StronglyConnectedComponents(const vector<vector<int>>& E) {",
      "  int N = int(E.size());",
      "  vector<bool> done(N);",
      "  vector<int> pos(N, -1), stack;",
      "  vector<vector<int>> res;",
      "  auto dfs = [&](auto& dfs, int u) -> int {",
      "    int low = pos[u] = int(stack.size());",
      "    stack.push_back(u);",
      "    for (int v : E[u]) {",
      "      if (!done[v]) {",
      "        low = min(low, pos[v] == -1 ? dfs(dfs, v) : pos[v]);",
      "      }",
      "    }",
      "    if (low == pos[u]) {",
      "      res.emplace_back(stack.begin() + low, stack.end());",
      "      for (int v : res.back()) {",
      "        done[v] = true;",
      "      }",
      "      stack.resize(low);",
      "    }",
      "    return low;",
      "  };",
      "  for (int i = 0; i < N; i++) {",
      "    if (!done[i]) {",
      "      dfs(dfs, i);",
      "    }",
      "  }",
      "  reverse(res.begin(), res.end());",
      "  return res;",
      "}"
    ],
    "description": "StronglyConnectedComponents"
  },
  "sieve": {
    "prefix": "!sieve",
    "body": [
      "vector<int> minp;",
      "vector<int> primes;",
      "void sieve(int N) {",
      "  minp.assign(N + 1, 0);",
      "  primes.clear();",
      "  for (int i = 2; i <= N; i++) {",
      "    if (minp[i] == 0) {",
      "      minp[i] = i;",
      "      primes.push_back(i);",
      "    }",
      "    for (auto p : primes) {",
      "      if (i * p > N) {",
      "        break;",
      "      }",
      "      minp[i * p] = p;",
      "      if (p == minp[i]) {",
      "        break;",
      "      }",
      "    }",
      "  }",
      "}",
      "bool isprime(int x) { return minp[x] == x; }"
    ],
    "description": "sieve"
  },
  "LIS": {
    "prefix": "!LIS",
    "body": [
      "vector<int> LIS(const vector<int>& a) {",
      "  int n = int(a.size());",
      "  vector<int> dp(n);",
      "  vector<int> b(n + 1, n + 1);",
      "  b[0] = -1;",
      "  for (int i = 0; i < n; i++) {",
      "    int l = 0, r = i;",
      "    while (l < r) {",
      "      int m = (l + r + 1) / 2;",
      "      if (b[m] < a[i]) {",
      "        l = m;",
      "      } else {",
      "        r = m - 1;",
      "      }",
      "    }",
      "    dp[i] = l + 1;",
      "    b[dp[i]] = min(b[dp[i]], a[i]);",
      "  }",
      "  return dp;",
      "}"
    ],
    "description": "LIS"
  },
  "mod": {
    "prefix": "!mod",
    "body": [
      "const long long MOD = 998244353;",
      "long long modpow(long long a, long long k) {",
      "  long long r = 1;",
      "  while (k > 0) {",
      "    if (k & 1) {",
      "      r = r * a % MOD;",
      "    }",
      "    a = a * a % MOD;",
      "    k /= 2;",
      "  }",
      "  return r;",
      "}",
      "long long modinv(long long a) { return modpow(a, MOD - 2); }",
      "vector<long long> fact(1, 1);",
      "vector<long long> ifact(1, 1);",
      "long long binom(int a, int b) {",
      "  if (a < b || b < 0) {",
      "    return 0;",
      "  }",
      "  if (fact.size() <= a) {",
      "    int n = fact.size();",
      "    int m = n;",
      "    while (m <= a) {",
      "      m *= 2;",
      "    }",
      "    fact.resize(m);",
      "    for (int i = n; i < m; i++) {",
      "      fact[i] = fact[i - 1] * i % MOD;",
      "    }",
      "    ifact.resize(m);",
      "    ifact[m - 1] = modinv(fact[m - 1], MOD - 2);",
      "    for (int i = m - 1; i > n; i--) {",
      "      ifact[i - 1] = ifact[i] * i % MOD;",
      "    }",
      "  }",
      "  return fact[a] * ifact[b] % MOD * ifact[a - b] % MOD;",
      "}"
    ],
    "description": "mod"
  },
  "Trie": {
    "prefix": "!Trie",
    "body": [
      "template <int sigma>",
      "struct Trie {",
      "  struct Node {",
      "    array<int, sigma> ch;",
      "    array<int, sigma> nxt;",
      "    int par;",
      "    int suffix_link;",
      "  };",
      "  int n_node;",
      "  vector<Node> nodes;",
      "  vector<int> words;",
      "  vector<int> BFS;",
      "  Trie() {",
      "    n_node = 0;",
      "    new_node();",
      "  }",
      "  int new_node() {",
      "    Node c;",
      "    fill(c.ch.begin(), c.ch.end(), -1);",
      "    fill(c.nxt.begin(), c.nxt.end(), -1);",
      "    c.par = -1;",
      "    c.suffix_link = -1;",
      "    nodes.emplace_back(c);",
      "    return n_node++;",
      "  }",
      "  Node& operator[](int i) { return nodes[i]; }",
      "  template <typename T>",
      "  int add(T S, int off) {",
      "    int p = 0;",
      "    for (auto s : S) {",
      "      p = add_single(p, s, off);",
      "    }",
      "    words.emplace_back(p);",
      "    return p;",
      "  }",
      "  int add_single(int p, int c, int off) {",
      "    c -= off;",
      "    assert(0 <= c && c < sigma);",
      "    if (nodes[p].ch[c] != -1) {",
      "      return nodes[p].ch[c];",
      "    }",
      "    nodes[p].ch[c] = new_node();",
      "    nodes.back().par = p;",
      "    return nodes[p].ch[c];",
      "  }",
      "  void calc_suffix_link() {",
      "    BFS.resize(n_node);",
      "    int p = 0;",
      "    BFS[p++] = 0;",
      "    for (int i = 0; i < p; i++) {",
      "      int u = BFS[i];",
      "      for (int j = 0; j < sigma; j++) {",
      "        int v = nodes[u].ch[j];",
      "        if (v == -1) {",
      "          if (u > 0) {",
      "            nodes[u].nxt[j] = nodes[nodes[u].suffix_link].nxt[j];",
      "          } else {",
      "            nodes[u].nxt[j] = 0;",
      "          }",
      "        } else {",
      "          nodes[u].nxt[j] = v;",
      "          if (u > 0) {",
      "            nodes[v].suffix_link = nodes[nodes[u].suffix_link].nxt[j];",
      "          } else {",
      "            nodes[v].suffix_link = 0;",
      "          }",
      "          BFS[p++] = v;",
      "        }",
      "      }",
      "    }",
      "  }",
      "};"
    ],
    "description": "Trie"
  },
  "LowestCommonAncestor": {
    "prefix": "!LowestCommonAncestor",
    "body": [
      "struct LowestCommonAncestor {",
      "  int h;",
      "  vector<vector<int>> G, par;",
      "  vector<int> dep;",
      "  bool LCA_BUILD = false;",
      "  LowestCommonAncestor(int n) : G(n), dep(n) {",
      "    h = 1;",
      "    while ((1 << h) <= n) h++;",
      "    par.assign(h, vector<int>(n, -1));",
      "  }",
      "  void add_edge(int u, int v) {",
      "    G[u].push_back(v);",
      "    G[v].push_back(u);",
      "  }",
      "  void dfs(int u, int p, int d) {",
      "    par[0][u] = p;",
      "    dep[u] = d;",
      "    for (int v : G[u]) {",
      "      if (v != p) {",
      "        dfs(v, u, d + 1);",
      "      }",
      "    }",
      "  }",
      "  void build(int r = 0) {",
      "    LCA_BUILD = true;",
      "    int n = (int)G.size();",
      "    dfs(r, -1, 0);",
      "    for (int i = 0; i + 1 < h; i++) {",
      "      for (int j = 0; j < n; j++) {",
      "        if (par[i][j] != -1) {",
      "          par[i + 1][j] = par[i][par[i][j]];",
      "        }",
      "      }",
      "    }",
      "  }",
      "  int lca(int u, int v) {",
      "    assert(LCA_BUILD);",
      "    if (dep[u] < dep[v]) swap(u, v);",
      "    for (int i = 0; i < h; i++) {",
      "      if ((dep[u] - dep[v]) & (1 << i)) u = par[i][u];",
      "    }",
      "    if (u == v) return u;",
      "    for (int i = h - 1; i >= 0; i--) {",
      "      if (par[i][u] != par[i][v]) {",
      "        u = par[i][u];",
      "        v = par[i][v];",
      "      }",
      "    }",
      "    return par[0][u];",
      "  }",
      "  int distance(int u, int v) {",
      "    assert(LCA_BUILD);",
      "    return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
      "  }",
      "};"
    ],
    "description": "LowestCommonAncestor"
  },
  "matching": {
    "prefix": "!matching",
    "body": [
      "struct matching {",
      "  int N, M;",
      "  vector<vector<int>> E;",
      "  vector<int> A;",
      "  vector<int> B;",
      "  vector<int> was;",
      "  int res;",
      "  int iter;",
      "  matching(int _N, int _M) : N(_N), M(_M) {",
      "    assert(0 <= N && 0 <= M);",
      "    A = vector<int>(N, -1);",
      "    B = vector<int>(M, -1);",
      "    was = vector<int>(N, 0);",
      "    E.resize(N);",
      "    res = iter = 0;",
      "  }",
      "  void add_edge(int u, int v) {",
      "    assert(0 <= u && u < N && 0 <= v && v < M);",
      "    E[u].push_back(v);",
      "  }",
      "  bool dfs(int u) {",
      "    was[u] = iter;",
      "    for (int v : E[u]) {",
      "      if (B[v] == -1) {",
      "        A[u] = v;",
      "        B[v] = u;",
      "        return true;",
      "      }",
      "    }",
      "    for (int v : E[u]) {",
      "      if (was[B[v]] != iter && dfs(B[v])) {",
      "        A[u] = v;",
      "        B[v] = u;",
      "        return true;",
      "      }",
      "    }",
      "    return false;",
      "  }",
      "  int solve() {",
      "    mt19937_64 rng(uint32_t(chrono::steady_clock::now().time_since_epoch().count()));",
      "    for (int i = 0; i < N; i++) {",
      "      shuffle(E[i].begin(), E[i].end(), rng);",
      "    }",
      "    while (true) {",
      "      iter++;",
      "      int add = 0;",
      "      for (int i = 0; i < N; i++) {",
      "        if (A[i] == -1 && dfs(i)) {",
      "          add++;",
      "        }",
      "      }",
      "      if (add == 0) {",
      "        break;",
      "      }",
      "      res += add;",
      "    }",
      "    return res;",
      "  }",
      "};"
    ],
    "description": "matching"
  },
  "RollingHash": {
    "prefix": "!RollingHash",
    "body": [
      "mt19937_64 mt(random_device{}());",
      "long long rng(long long v) { return mt() % v; }",
      "using hash_t = array<long long, 2>;",
      "const hash_t hash_mod = {1000000007, 1000000009};",
      "const hash_t base = {23333, 12223};",
      "hash_t operator+(const hash_t &a, const hash_t &b) {",
      "  hash_t res;",
      "  for (int i = 0; i < 2; i++) {",
      "    res[i] = (a[i] + b[i]) % hash_mod[i];",
      "  }",
      "  return res;",
      "}",
      "hash_t operator-(const hash_t &a, const hash_t &b) {",
      "  hash_t res;",
      "  for (int i = 0; i < 2; i++) {",
      "    res[i] = (a[i] - b[i] + hash_mod[i]) % hash_mod[i];",
      "  }",
      "  return res;",
      "}",
      "hash_t operator*(const hash_t &a, const hash_t &b) {",
      "  hash_t res;",
      "  for (int i = 0; i < 2; i++) {",
      "    res[i] = a[i] * b[i] % hash_mod[i];",
      "  }",
      "  return res;",
      "}",
      "vector<hash_t> hash_pow{{1, 1}};",
      "void hash_expend(int m) {",
      "  int n = (int)hash_pow.size();",
      "  if (m > n) {",
      "    hash_pow.resize(m);",
      "    for (int i = n; i < m; i++) {",
      "      hash_pow[i] = hash_pow[i - 1] * base;",
      "    }",
      "  }",
      "}",
      "vector<hash_t> hash_sig(128, {-1, -1});",
      "struct RollingHash {",
      "  vector<hash_t> h;",
      "  template <typename T>",
      "  RollingHash(const vector<T> &s) {",
      "    int n = (int)s.size();",
      "    h.assign(n + 1, {0, 0});",
      "    hash_expend(n + 1);",
      "    for (int i = 0; i < n; i++) {",
      "      if (hash_sig[s[i]] == hash_t{-1, -1}) {",
      "        hash_sig[s[i]] = {rng(hash_mod[0]), rng(hash_mod[1])};",
      "      }",
      "      h[i + 1] = h[i] * base + hash_sig[s[i]];",
      "    }",
      "  }",
      "  RollingHash(const string &s)",
      "      : RollingHash(vector<char>(s.begin(), s.end())) {}",
      "  hash_t get(int l, int r) { return h[r] - h[l] * hash_pow[r - l]; }",
      "};"
    ],
    "description": "RollingHash"
  },
  "ckminmax": {
    "prefix": "!ckminmax",
    "body": [
      "template <typename T, typename U>",
      "bool ckmin(T &a, const U &b) {",
      "  return b < a ? a = b, true : false;",
      "}",
      "template <typename T, typename U>",
      "bool ckmax(T &a, const U &b) {",
      "  return a < b ? a = b, true : false;",
      "}"
    ],
    "description": "ckminmax"
  },
  "AuxiliaryTree": {
    "prefix": "!AuxiliaryTree",
    "body": [
      "struct AuxiliaryTree : LowestCommonAncestor {",
      "  using super = LowestCommonAncestor;",
      "  vector<int> tin;",
      "  vector<vector<int>> E;",
      "  bool AT_BUILD = false;",
      "  AuxiliaryTree(int n) : super(n), tin(n), E(n) {}",
      "  void dfs(int u, int p, int &pos) {",
      "    tin[u] = pos++;",
      "    for (int v : G[u]) {",
      "      if (v != p) {",
      "        dfs(v, u, pos);",
      "      }",
      "    }",
      "  }",
      "  void build(int r = 0) {",
      "    super::build(r);",
      "    AT_BUILD = true;",
      "    int pos = 0;",
      "    dfs(r, -1, pos);",
      "  }",
      "  void add_aux_edge(int u, int v) {",
      "    E[u].push_back(v);",
      "    E[v].push_back(u);",
      "  }",
      "  using super::dep;",
      "  using super::lca;",
      "  void query(vector<int> a) {",
      "    assert(AT_BUILD);",
      "    int n = a.size();",
      "    sort(a.begin(), a.end(), [&](int x, int y) { return tin[x] < tin[y]; });",
      "    for (int i = 0; i + 1 < n; i++) {",
      "      a.push_back(lca(a[i], a[i + 1]));",
      "    }",
      "    a.push_back(0);",
      "    sort(a.begin(), a.end(), [&](int x, int y) { return tin[x] < tin[y]; });",
      "    a.erase(unique(a.begin(), a.end()), a.end());",
      "    for (int i = 0; i + 1 < (int)a.size(); i++) {",
      "      add_aux_edge(lca(a[i], a[i + 1]), a[i + 1]);",
      "    }",
      "  }",
      "  void clear(int u = 0, int p = -1) {",
      "    for (int v : E[u]) {",
      "      if (v != p) {",
      "        clear(v, u);",
      "      }",
      "    }",
      "    E[u].clear();",
      "  }",
      "};"
    ],
    "description": "AuxiliaryTree"
  },
  "dinic": {
    "prefix": "!dinic",
    "body": [
      "template <class T>",
      "struct dinic {",
      "  int n;",
      "  vector<tuple<int, int, T>> e;",
      "  vector<vector<int>> adj;",
      "  vector<int> lev;",
      "  dinic(int n_) : n(n_), adj(n) {}",
      "  int add_edge(int u, int v, T c) {",
      "    int i = e.size();",
      "    e.emplace_back(u, v, c);",
      "    e.emplace_back(v, u, 0);",
      "    adj[u].push_back(i);",
      "    adj[v].push_back(i ^ 1);",
      "    return i;",
      "  }",
      "  T max_flow(int s, int t) {",
      "    T flow = 0;",
      "    queue<int> q;",
      "    vector<int> cur;",
      "    auto bfs = [&]() {",
      "      lev.assign(n, -1);",
      "      lev[s] = 0;",
      "      q.push(s);",
      "      while (!q.empty()) {",
      "        int u = q.front();",
      "        q.pop();",
      "        for (int i : adj[u]) {",
      "          auto [_, v, c] = e[i];",
      "          if (c > 0 && lev[v] == -1) {",
      "            lev[v] = lev[u] + 1;",
      "            q.push(v);",
      "          }",
      "        }",
      "      }",
      "      return ~lev[t];",
      "    };",
      "    auto dfs = [&](auto &&dfs, int u, T lim) -> T {",
      "      if (u == t) {",
      "        return lim;",
      "      }",
      "      T res = 0;",
      "      for (int &i = cur[u]; i < (int)adj[u].size() && lim > 0; i++) {",
      "        int j = adj[u][i];",
      "        auto [_, v, c] = e[j];",
      "        if (lev[v] == lev[u] + 1 && c > 0) {",
      "          T d = dfs(dfs, v, min(c, lim));",
      "          if (d > 0) {",
      "            lim -= d;",
      "            res += d;",
      "            get<2>(e[j]) -= d;",
      "            get<2>(e[j ^ 1]) += d;",
      "          }",
      "        }",
      "      }",
      "      return res;",
      "    };",
      "    while (bfs()) {",
      "      cur.assign(n, 0);",
      "      while (T f = dfs(dfs, s, numeric_limits<T>::max())) {",
      "        flow += f;",
      "      }",
      "    }",
      "    return flow;",
      "  }",
      "};"
    ],
    "description": "dinic"
  },
  "FenwickTree": {
    "prefix": "!FenwickTree",
    "body": [
      "template <typename T>",
      "struct FenwickTree {",
      "  int n;",
      "  vector<T> f;",
      "  FenwickTree() {}",
      "  FenwickTree(int _n) : n(_n) { f.assign(_n, T()); }",
      "  void add(int i, T x) {",
      "    for (int j = i + 1; j <= n; j += j & -j) {",
      "      f[j - 1] += x;",
      "    }",
      "  }",
      "  T sum(int i) {",
      "    T res = 0;",
      "    for (int j = i; j > 0; j -= j & -j) {",
      "      res += f[j - 1];",
      "    }",
      "    return res;",
      "  }",
      "  T sum(int i, int j) { return sum(j) - sum(i); }",
      "};"
    ],
    "description": "FenwickTree"
  },
  "modint": {
    "prefix": "!modint",
    "body": [
      "template <typename T>",
      "T mod_inv_in_range(T a, T m) {",
      "  // assert(0 <= a && a < m);",
      "  T x = a, y = m;",
      "  // coeff of a in x and y",
      "  T vx = 1, vy = 0;",
      "  while (x) {",
      "    T k = y / x;",
      "    y %= x;",
      "    vy -= k * vx;",
      "    std::swap(x, y);",
      "    std::swap(vx, vy);",
      "  }",
      "  assert(y == 1);",
      "  return vy < 0 ? m + vy : vy;",
      "}",
      "template <typename T>",
      "struct extended_gcd_result {",
      "  T gcd;",
      "  T coeff_a, coeff_b;",
      "};",
      "template <typename T>",
      "extended_gcd_result<T> extended_gcd(T a, T b) {",
      "  T x = a, y = b;",
      "  // coeff of a and b in x and y",
      "  T ax = 1, ay = 0;",
      "  T bx = 0, by = 1;",
      "  while (x) {",
      "    T k = y / x;",
      "    y %= x;",
      "    ay -= k * ax;",
      "    by -= k * bx;",
      "    std::swap(x, y);",
      "    std::swap(ax, ay);",
      "    std::swap(bx, by);",
      "  }",
      "  return {y, ay, by};",
      "}",
      "template <typename T>",
      "T mod_inv(T a, T m) {",
      "  a %= m;",
      "  a = a < 0 ? a + m : a;",
      "  return mod_inv_in_range(a, m);",
      "}",
      "template <int MOD_>",
      "struct modnum {",
      "  static constexpr int MOD = MOD_;",
      "  static_assert(MOD_ > 0, \"MOD must be positive\");",
      "",
      " private:",
      "  int v;",
      "",
      " public:",
      "  modnum() : v(0) {}",
      "  modnum(int64_t v_) : v(int(v_ % MOD)) {",
      "    if (v < 0) v += MOD;",
      "  }",
      "  explicit operator int() const { return v; }",
      "  friend std::ostream& operator<<(std::ostream& out, const modnum& n) { return out << int(n); }",
      "  friend std::istream& operator>>(std::istream& in, modnum& n) {",
      "    int64_t v_;",
      "    in >> v_;",
      "    n = modnum(v_);",
      "    return in;",
      "  }",
      "  friend bool operator==(const modnum& a, const modnum& b) { return a.v == b.v; }",
      "  friend bool operator!=(const modnum& a, const modnum& b) { return a.v != b.v; }",
      "  modnum inv() const {",
      "    modnum res;",
      "    res.v = mod_inv_in_range(v, MOD);",
      "    return res;",
      "  }",
      "  friend modnum inv(const modnum& m) { return m.inv(); }",
      "  modnum neg() const {",
      "    modnum res;",
      "    res.v = v ? MOD - v : 0;",
      "    return res;",
      "  }",
      "  friend modnum neg(const modnum& m) { return m.neg(); }",
      "  modnum operator-() const { return neg(); }",
      "  modnum operator+() const { return modnum(*this); }",
      "  modnum& operator++() {",
      "    v++;",
      "    if (v == MOD) v = 0;",
      "    return *this;",
      "  }",
      "  modnum& operator--() {",
      "    if (v == 0) v = MOD;",
      "    v--;",
      "    return *this;",
      "  }",
      "  modnum& operator+=(const modnum& o) {",
      "    v -= MOD - o.v;",
      "    v = (v < 0) ? v + MOD : v;",
      "    return *this;",
      "  }",
      "  modnum& operator-=(const modnum& o) {",
      "    v -= o.v;",
      "    v = (v < 0) ? v + MOD : v;",
      "    return *this;",
      "  }",
      "  modnum& operator*=(const modnum& o) {",
      "    v = int(int64_t(v) * int64_t(o.v) % MOD);",
      "    return *this;",
      "  }",
      "  modnum& operator/=(const modnum& o) { return *this *= o.inv(); }",
      "  friend modnum operator++(modnum& a, int) {",
      "    modnum r = a;",
      "    ++a;",
      "    return r;",
      "  }",
      "  friend modnum operator--(modnum& a, int) {",
      "    modnum r = a;",
      "    --a;",
      "    return r;",
      "  }",
      "  friend modnum operator+(const modnum& a, const modnum& b) { return modnum(a) += b; }",
      "  friend modnum operator-(const modnum& a, const modnum& b) { return modnum(a) -= b; }",
      "  friend modnum operator*(const modnum& a, const modnum& b) { return modnum(a) *= b; }",
      "  friend modnum operator/(const modnum& a, const modnum& b) { return modnum(a) /= b; }",
      "};",
      "template <typename T>",
      "T pow(T a, long long b) {",
      "  assert(b >= 0);",
      "  T r = 1;",
      "  while (b) {",
      "    if (b & 1) r *= a;",
      "    b >>= 1;",
      "    a *= a;",
      "  }",
      "  return r;",
      "}",
      "using num = modnum<998244353>;",
      "// using num = modnum<int(1e9) + 7>;",
      "",
      "vector<num> fact, ifact;",
      "bool FACT_INIT = false;",
      "void init() {",
      "  FACT_INIT = true;",
      "  int N = 4.1e5;",
      "  fact.resize(N);",
      "  fact[0] = 1;",
      "  for (int i = 1; i < N; i++) {",
      "    fact[i] = fact[i - 1] * i;",
      "  }",
      "  ifact.resize(N);",
      "  ifact.back() = 1 / fact.back();",
      "  for (int i = N - 1; i > 0; i--) {",
      "    ifact[i - 1] = ifact[i] * i;",
      "  }",
      "}",
      "num ncr(int n, int k) {",
      "  assert(FACT_INIT);",
      "  if (k < 0 || k > n) {",
      "    return 0;",
      "  } else {",
      "    return fact[n] * ifact[k] * ifact[n - k];",
      "  }",
      "}"
    ],
    "description": "modint"
  },
  "UnionFind": {
    "prefix": "!UnionFind",
    "body": [
      "struct UnionFind {",
      "  int cnt = 0;",
      "  vector<int> p;",
      "  UnionFind(int n) {",
      "    p = vector<int>(n, -1);",
      "    cnt = n;",
      "  }",
      "  int root(int x) {",
      "    if (p[x] < 0) {",
      "      return x;",
      "    } else {",
      "      p[x] = root(p[x]);",
      "      return p[x];",
      "    }",
      "  }",
      "  bool same(int x, int y) { return root(x) == root(y); }",
      "  bool unite(int x, int y) {",
      "    x = root(x);",
      "    y = root(y);",
      "    if (x != y) {",
      "      if (p[x] < p[y]) {",
      "        swap(x, y);",
      "      }",
      "      p[y] += p[x];",
      "      p[x] = y;",
      "      cnt--;",
      "      return true;",
      "    } else {",
      "      return false;",
      "    }",
      "  }",
      "};"
    ],
    "description": "UnionFind"
  },
  "main": {
    "prefix": "!main",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#ifdef LOCAL",
      "#include \"debug.h\"",
      "#else",
      "#define debug(...) 42",
      "#endif",
      "",
      "#define all(v) (v).begin(), (v).end()",
      "#define sz(v) ((int)(v).size())",
      "using ll = long long;",
      "using ii = pair<int, int>;",
      "",
      "int main() {",
      "  cin.tie(nullptr)->ios_base::sync_with_stdio(false);",
      "  cout << setprecision(20);",
      "  ${0}",
      "}"
    ],
    "description": "main"
  },
  "segtree": {
    "prefix": "!segtree",
    "body": [
      "namespace atcoder {",
      "namespace internal {",
      "#if __cplusplus >= 202002L",
      "using std::bit_ceil;",
      "#else",
      "// @return same with std::bit::bit_ceil",
      "unsigned int bit_ceil(unsigned int n) {",
      "  unsigned int x = 1;",
      "  while (x < (unsigned int)(n)) x *= 2;",
      "  return x;",
      "}",
      "#endif",
      "// @param n `1 <= n`",
      "// @return same with std::bit::countr_zero",
      "int countr_zero(unsigned int n) {",
      "#ifdef _MSC_VER",
      "  unsigned long index;",
      "  BitScanForward(&index, n);",
      "  return index;",
      "#else",
      "  return __builtin_ctz(n);",
      "#endif",
      "}",
      "// @param n `1 <= n`",
      "// @return same with std::bit::countr_zero",
      "constexpr int countr_zero_constexpr(unsigned int n) {",
      "  int x = 0;",
      "  while (!(n & (1 << x))) x++;",
      "  return x;",
      "}",
      "}  // namespace internal",
      "}  // namespace atcoder",
      "",
      "namespace atcoder {",
      "#if __cplusplus >= 201703L",
      "template <class S, auto op, auto e>",
      "struct segtree {",
      "  static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,",
      "                \"op must work as S(S, S)\");",
      "  static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,",
      "                \"e must work as S()\");",
      "#else",
      "template <class S, S (*op)(S, S), S (*e)()>",
      "struct segtree {",
      "#endif",
      " public:",
      "  segtree() : segtree(0) {}",
      "  explicit segtree(int n) : segtree(std::vector<S>(n, e())) {}",
      "  explicit segtree(const std::vector<S>& v) : _n(int(v.size())) {",
      "    size = (int)internal::bit_ceil((unsigned int)(_n));",
      "    log = internal::countr_zero((unsigned int)size);",
      "    d = std::vector<S>(2 * size, e());",
      "    for (int i = 0; i < _n; i++) d[size + i] = v[i];",
      "    for (int i = size - 1; i >= 1; i--) {",
      "      update(i);",
      "    }",
      "  }",
      "  void set(int p, S x) {",
      "    assert(0 <= p && p < _n);",
      "    p += size;",
      "    d[p] = x;",
      "    for (int i = 1; i <= log; i++) update(p >> i);",
      "  }",
      "  S get(int p) const {",
      "    assert(0 <= p && p < _n);",
      "    return d[p + size];",
      "  }",
      "  S prod(int l, int r) const {",
      "    assert(0 <= l && l <= r && r <= _n);",
      "    S sml = e(), smr = e();",
      "    l += size;",
      "    r += size;",
      "",
      "    while (l < r) {",
      "      if (l & 1) sml = op(sml, d[l++]);",
      "      if (r & 1) smr = op(d[--r], smr);",
      "      l >>= 1;",
      "      r >>= 1;",
      "    }",
      "    return op(sml, smr);",
      "  }",
      "  S all_prod() const { return d[1]; }",
      "  template <bool (*f)(S)>",
      "  int max_right(int l) const {",
      "    return max_right(l, [](S x) { return f(x); });",
      "  }",
      "  template <class F>",
      "  int max_right(int l, F f) const {",
      "    assert(0 <= l && l <= _n);",
      "    assert(f(e()));",
      "    if (l == _n) return _n;",
      "    l += size;",
      "    S sm = e();",
      "    do {",
      "      while (l % 2 == 0) l >>= 1;",
      "      if (!f(op(sm, d[l]))) {",
      "        while (l < size) {",
      "          l = (2 * l);",
      "          if (f(op(sm, d[l]))) {",
      "            sm = op(sm, d[l]);",
      "            l++;",
      "          }",
      "        }",
      "        return l - size;",
      "      }",
      "      sm = op(sm, d[l]);",
      "      l++;",
      "    } while ((l & -l) != l);",
      "    return _n;",
      "  }",
      "  template <bool (*f)(S)>",
      "  int min_left(int r) const {",
      "    return min_left(r, [](S x) { return f(x); });",
      "  }",
      "  template <class F>",
      "  int min_left(int r, F f) const {",
      "    assert(0 <= r && r <= _n);",
      "    assert(f(e()));",
      "    if (r == 0) return 0;",
      "    r += size;",
      "    S sm = e();",
      "    do {",
      "      r--;",
      "      while (r > 1 && (r % 2)) r >>= 1;",
      "      if (!f(op(d[r], sm))) {",
      "        while (r < size) {",
      "          r = (2 * r + 1);",
      "          if (f(op(d[r], sm))) {",
      "            sm = op(d[r], sm);",
      "            r--;",
      "          }",
      "        }",
      "        return r + 1 - size;",
      "      }",
      "      sm = op(d[r], sm);",
      "    } while ((r & -r) != r);",
      "    return 0;",
      "  }",
      "",
      " private:",
      "  int _n, size, log;",
      "  std::vector<S> d;",
      "  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
      "};",
      "}  // namespace atcoder"
    ],
    "description": "segtree"
  }
}